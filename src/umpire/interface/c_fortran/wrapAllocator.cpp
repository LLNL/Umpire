// wrapAllocator.cpp
// This file is generated by Shroud 0.12.2. Do not edit.
// Copyright (c) 2016-23, Lawrence Livermore National Security, LLC and Umpire
// project contributors. See the COPYRIGHT file for details.
//
// SPDX-License-Identifier: (MIT)
#include "wrapAllocator.h"
#include <cstddef>
#include <cstring>
#include <string>
#include "umpire/Allocator.hpp"

// splicer begin class.Allocator.CXX_definitions
// splicer end class.Allocator.CXX_definitions

extern "C" {


// helper ShroudStrToArray
// Save str metadata into array to allow Fortran to access values.
// CHARACTER(len=elem_size) src
static void ShroudStrToArray(umpire_SHROUD_array *array, const std::string * src, int idtor)
{
    array->cxx.addr = const_cast<std::string *>(src);
    array->cxx.idtor = idtor;
    if (src->empty()) {
        array->addr.ccharp = NULL;
        array->elem_len = 0;
    } else {
        array->addr.ccharp = src->data();
        array->elem_len = src->length();
    }
    array->size = 1;
    array->rank = 0;  // scalar
}
// splicer begin class.Allocator.C_definitions
// splicer end class.Allocator.C_definitions

void umpire_allocator_delete(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.delete
    delete SH_this;
    self->addr = nullptr;
    // splicer end class.Allocator.method.delete
}

void * umpire_allocator_allocate(umpire_allocator * self, size_t bytes)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.allocate
    void * SHC_rv = SH_this->allocate(bytes);
    return SHC_rv;
    // splicer end class.Allocator.method.allocate
}

void umpire_allocator_deallocate(umpire_allocator * self, void * ptr)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.deallocate
    SH_this->deallocate(ptr);
    // splicer end class.Allocator.method.deallocate
}

void umpire_allocator_release(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.release
    SH_this->release();
    // splicer end class.Allocator.method.release
}

size_t umpire_allocator_get_size(umpire_allocator * self, void * ptr)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_size
    size_t SHC_rv = SH_this->getSize(ptr);
    return SHC_rv;
    // splicer end class.Allocator.method.get_size
}

size_t umpire_allocator_get_high_watermark(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_high_watermark
    size_t SHC_rv = SH_this->getHighWatermark();
    return SHC_rv;
    // splicer end class.Allocator.method.get_high_watermark
}

size_t umpire_allocator_get_current_size(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_current_size
    size_t SHC_rv = SH_this->getCurrentSize();
    return SHC_rv;
    // splicer end class.Allocator.method.get_current_size
}

size_t umpire_allocator_get_actual_size(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_actual_size
    size_t SHC_rv = SH_this->getActualSize();
    return SHC_rv;
    // splicer end class.Allocator.method.get_actual_size
}

size_t umpire_allocator_get_allocation_count(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_allocation_count
    size_t SHC_rv = SH_this->getAllocationCount();
    return SHC_rv;
    // splicer end class.Allocator.method.get_allocation_count
}

const char * umpire_allocator_get_name(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_name
    const std::string & SHCXX_rv = SH_this->getName();
    const char * SHC_rv = SHCXX_rv.c_str();
    return SHC_rv;
    // splicer end class.Allocator.method.get_name
}

void umpire_allocator_get_name_bufferify(umpire_allocator * self,
    umpire_SHROUD_array *DSHF_rv)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_name_bufferify
    const std::string & SHCXX_rv = SH_this->getName();
    ShroudStrToArray(DSHF_rv, &SHCXX_rv, 0);
    // splicer end class.Allocator.method.get_name_bufferify
}

size_t umpire_allocator_get_id(umpire_allocator * self)
{
    umpire::Allocator *SH_this =
        static_cast<umpire::Allocator *>(self->addr);
    // splicer begin class.Allocator.method.get_id
    size_t SHC_rv = SH_this->getId();
    return SHC_rv;
    // splicer end class.Allocator.method.get_id
}

}  // extern "C"
