// wrapUmpire.cpp
// This file is generated by Shroud 0.11.0. Do not edit.
// Copyright (c) 2016-20, Lawrence Livermore National Security, LLC and Umpire
// project contributors. See the COPYRIGHT file for details.
//
// SPDX-License-Identifier: (MIT)
#include "wrapUmpire.h"
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <string>
#include "typesUmpire.h"
#include "umpire/Umpire.hpp"

#include "umpire/Allocator.hpp"

// splicer begin CXX_definitions
// splicer end CXX_definitions

extern "C" {


// helper ShroudStrToArray
// Save str metadata into array to allow Fortran to access values.
static void ShroudStrToArray(umpire_SHROUD_array *array, const std::string * src, int idtor)
{
    array->cxx.addr = static_cast<void *>(const_cast<std::string *>(src));
    array->cxx.idtor = idtor;
    if (src->empty()) {
        array->addr.ccharp = NULL;
        array->elem_len = 0;
    } else {
        array->addr.ccharp = src->data();
        array->elem_len = src->length();
    }
    array->size = 1;
    array->rank = 1;
}
// splicer begin C_definitions
// splicer end C_definitions

bool umpire_pointer_overlaps(void * left, void * right)
{
    // splicer begin function.pointer_overlaps
    bool SHC_rv = umpire::pointer_overlaps(left, right);
    return SHC_rv;
    // splicer end function.pointer_overlaps
}

bool umpire_pointer_contains(void * left, void * right)
{
    // splicer begin function.pointer_contains
    bool SHC_rv = umpire::pointer_contains(left, right);
    return SHC_rv;
    // splicer end function.pointer_contains
}

void umpire_get_backtrace_bufferify(void * ptr,
    umpire_SHROUD_array *DSHF_rv)
{
    // splicer begin function.get_backtrace_bufferify
    std::string * SHCXX_rv = new std::string;
    *SHCXX_rv = umpire::get_backtrace(ptr);
    ShroudStrToArray(DSHF_rv, SHCXX_rv, 2);
    // splicer end function.get_backtrace_bufferify
}

size_t umpire_get_process_memory_usage()
{
    // splicer begin function.get_process_memory_usage
    size_t SHC_rv = umpire::get_process_memory_usage();
    return SHC_rv;
    // splicer end function.get_process_memory_usage
}

size_t umpire_get_device_memory_usage(int device_id)
{
    // splicer begin function.get_device_memory_usage
    size_t SHC_rv = umpire::get_device_memory_usage(device_id);
    return SHC_rv;
    // splicer end function.get_device_memory_usage
}

// Release library allocated memory.
void umpire_SHROUD_memory_destructor(umpire_SHROUD_capsule_data *cap)
{
    void *ptr = cap->addr;
    switch (cap->idtor) {
    case 0:   // --none--
    {
        // Nothing to delete
        break;
    }
    case 1:   // umpire::Allocator
    {
        umpire::Allocator *cxx_ptr = 
            reinterpret_cast<umpire::Allocator *>(ptr);
        delete cxx_ptr;
        break;
    }
    case 2:   // new_string
    {
        std::string *cxx_ptr = reinterpret_cast<std::string *>(ptr);
        delete cxx_ptr;
        break;
    }
    default:
    {
        // Unexpected case in destructor
        break;
    }
    }
    cap->addr = nullptr;
    cap->idtor = 0;  // avoid deleting again
}

}  // extern "C"
